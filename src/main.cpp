#include <cstdio>
#include <cctype>
#include <cstring>
#include <cstdint>

using namespace std;

unsigned char data_array[] = {
	0xa1, 0xf8,
	0xFA, 0x33, 0xC0, 0x8E, 0xD0, 0xBC, 0x00, 0x7C, 0x8B, 0xF4, 0x50, 0x07, 0x50, 0x1F, 0xFB, 0xFC, 
	0xBF, 0x00, 0x06, 0xB9, 0x00, 0x01, 0xF2, 0xA5, 0xEA, 0x1D, 0x06, 0x00, 0x00, 0xBE, 0xBE, 0x07, 
	0xB3, 0x04, 0x80, 0x3C, 0x80, 0x74, 0x0E, 0x80, 0x3C, 0x00, 0x75, 0x1C, 0x83, 0xC6, 0x10, 0xFE, 
	0xCB, 0x75, 0xEF, 0xCD, 0x18, 0x8B, 0x14, 0x8B, 0x4C, 0x02, 0x8B, 0xEE, 0x83, 0xC6, 0x10, 0xFE, 
	0xCB, 0x74, 0x1A, 0x80, 0x3C, 0x00, 0x74, 0xF4, 0xBE, 0x8B, 0x06, 0xAC, 0x3C, 0x00, 0x74, 0x0B, 
	0x56, 0xBB, 0x07, 0x00, 0xB4, 0x0E, 0xCD, 0x10, 0x5E, 0xEB, 0xF0, 0xEB, 0xFE, 0xBF, 0x05, 0x00, 
	0xBB, 0x00, 0x7C, 0xB8, 0x01, 0x02, 0x57, 0xCD, 0x13, 0x5F, 0x73, 0x0C, 0x33, 0xC0, 0xCD, 0x13, 
	0x4F, 0x75, 0xED, 0xBE, 0xA3, 0x06, 0xEB, 0xD3, 0xBE, 0xC4, 0x06, 0xBF, 0xFE, 0x7D, 0x81, 0x3D, 
	0x55, 0xAA, 0x75, 0xC7, 0x8B, 0xF5, 0xEA, 0x00, 0x7C, 0x00, 0x00, 0x4F, 0x6E, 0x67, 0x65, 0x6C, 
	0x64, 0x69, 0x67, 0x65, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x65, 0x74, 0x61, 0x62, 
	0x65, 0x6C, 0x00, 0x46, 0x6F, 0x75, 0x74, 0x20, 0x62, 0x69, 0x6A, 0x20, 0x6C, 0x61, 0x64, 0x65, 
	0x6E, 0x20, 0x62, 0x65, 0x73, 0x74, 0x75, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x73, 0x79, 0x73, 0x74, 
	0x65, 0x65, 0x6D, 0x00, 0x47, 0x65, 0x65, 0x6E, 0x20, 0x62, 0x65, 0x73, 0x74, 0x75, 0x72, 0x69, 
	0x6E, 0x67, 0x73, 0x73, 0x79, 0x73, 0x74, 0x65, 0x65, 0x6D, 0x20, 0x61, 0x61, 0x6E, 0x77, 0x65, 
	0x7A, 0x69, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 
	0x01, 0x00, 0x01, 0x04, 0x11, 0xF9, 0x11, 0x00, 0x00, 0x00, 0xF1, 0x52, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0xFA, 0x05, 0x04, 0xD1, 0xD3, 0x02, 0x53, 0x00, 0x00, 0x62, 0xF2, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA,
	0x89, 0xF3, 0x48, 0x23
};

//////////////////////////

static const unsigned char BitReverseTable256[256] = 
{
#   define R2(n)     n,     n + 2*64,     n + 1*64,     n + 3*64
#   define R4(n) R2(n), R2(n + 2*16), R2(n + 1*16), R2(n + 3*16)
#   define R6(n) R4(n), R4(n + 2*4 ), R4(n + 1*4 ), R4(n + 3*4 )
    R6(0), R6(2), R6(1), R6(3)
};

uint32_t bitswap(const uint32_t v)
{
	return (BitReverseTable256[v & 0xff] << 24) |
		(BitReverseTable256[(v >> 8) & 0xff] << 16) |
		(BitReverseTable256[(v >> 16) & 0xff] << 8) |
		(BitReverseTable256[(v >> 24) & 0xff]);
}

////////////////////////////////

uint32_t crc32(const uint32_t initval, const uint32_t poly, const unsigned char *data, const size_t len)
{
	uint32_t crc = initval;
	ssize_t i = len;
	const unsigned char *d = data;

	while (i-- > 0) {
		unsigned char x = *(d++);

		for (int j=0; j<8; j++) {
			unsigned char feedback = (crc >> 31) ^ (x >> 7);

			crc = (crc << 1);

			if (feedback)
				crc ^= poly;

			x = x << 1;
		}
	}

	return crc;
}

uint32_t crc32_bit(const uint32_t initval, const uint32_t poly, char bit)
{
	uint32_t crc = initval;

	unsigned char feedback = (crc >> 31) ^ (bit & 1);
	crc = (crc << 1);
	if (feedback)
		crc ^= poly;

	return crc;
}

void hex_dump(void *data, int size)
{
	/* dumps size bytes of *data to stdout. Looks like:
	 * [0000] 75 6E 6B 6E 6F 77 6E 20
	 *                  30 FF 00 00 00 00 39 00 unknown 0.....9.
	 * (in a single line of course)
	 */

	unsigned char *p = (unsigned char *)data;
	unsigned long addr = 0;
	unsigned char c;
	int n;
	char bytestr[4] = {0};
	char addrstr[10] = {0};
	char hexstr[ 16*3 + 5] = {0};
	char charstr[16*1 + 5] = {0};
	for(n=1;n<=size;n++) {
		if (n%16 == 1) {
			/* store address for this line */
			snprintf(addrstr, sizeof(addrstr), "%.4lX",
			   addr);
		}

		c = *p;
		if (isprint(c) == 0) {
			c = '.';
		}

		/* store hex str (for left side) */
		snprintf(bytestr, sizeof(bytestr), "%02X ", *p);
		strncat(hexstr, bytestr, sizeof(hexstr)-strlen(hexstr)-1);

		/* store char str (for right side) */
		snprintf(bytestr, sizeof(bytestr), "%c", c);
		strncat(charstr, bytestr, sizeof(charstr)-strlen(charstr)-1);

		if(n%16 == 0) { 
			/* line completed */
			printf("[%4.4s]   %-50.50s  %s\n", addrstr, hexstr, charstr);
			hexstr[0] = 0;
			charstr[0] = 0;
		} else if(n%8 == 0) {
			/* half line: add whitespaces */
			strncat(hexstr, "  ", sizeof(hexstr)-strlen(hexstr)-1);
			strncat(charstr, " ", sizeof(charstr)-strlen(charstr)-1);
		}
		p++; /* next byte */
		addr++; /* increment address */
	}

	if (strlen(hexstr) > 0) {
		/* print rest of buffer if not empty */
		printf("[%4.4s]   %-50.50s  %s\n", addrstr, hexstr, charstr);
	}
}

//////////////////////////////////

int main(void)
{
	printf("\n\n"
			"#######################\n"
			"# CRC GENERATION TEST #\n"
			"#######################\n\n");

	unsigned char z[] = { 0xa1, 0xf8 };
	printf("%08X  [target]\n", 0xb517894a);
	printf("%08X  [calculated]\n", crc32(0xffffffff, 0x140A0445, z, 2));

	printf("%02X%02X%02X%02X  [target]\n",
			data_array[512+2],
			data_array[513+2],
			data_array[514+2],
			data_array[515+2]
		  );

	/***
	 * CRC parameters:
	 *   Polynomial             -- 0x140A0445
	 *   Initialisation Vector  -- 0xFFFFFFFF
	 *   Starting point         -- Start of DAM sync header (0xA1 0xF8)
	 *   End point              -- End of data payload
	 *   Total CRC length       -- sector_size + 2 bytes
	 *
	 * Interesting factoid: crc32(concat(data, crc32(data))) == 0.
	 */
	printf("%08X  [calculated]\n", crc32(0xffffffff, 0x140A0445, data_array, 512+2));

	// Try and do an error-correction run
	printf("\n\n"
			"#########################\n"
			"# ERROR CORRECTION TEST #\n"
			"#########################\n\n");

	// --- Preparation ---
	// 0a. CRC a data block
	unsigned char ec_z[] = {0xa1, 0xf8, 1,2,3,4,5,6,7,8,9,10, 0, 0, 0, 0};
	uint32_t c = crc32(0xFFFFFFFF, 0x140A0445, ec_z, sizeof(ec_z)-4);
	for (int i=sizeof(ec_z)-4; i<sizeof(ec_z); i++) {
		ec_z[i] = (c >> 24);
		c <<= 8;
	}

	hex_dump(ec_z, sizeof(ec_z));

	// 0b. Clobber some data. Max error span = 5 bits
	ec_z[8] ^= 0x0b;
	ec_z[9] ^= 0x80;

	// 0c. Recalculate the CRC as if we just read the track. This gets us
	// the CRC syndrome.
	// If the track were error-free, the syndrome would be zero.
	c = crc32(0xFFFFFFFF, 0x140A0445, ec_z, sizeof(ec_z));
	printf("CRC syndrome: %08X\n", c);

	// 1. Offload the 32bit syndrome into local RAM
	// 2. Shift the syndrome back into the ECC register in reverse order
	c = bitswap(c);

	// 3. Change the ECC polynomial from forward to reciprocal
//	POLY = (bitswap(POLY) << 1) | 1;

	// 4. Shift the ECC until all bits except the high order bits are zero
	// or the number of shifts becomes greater than the number of bits in
	// the record.
	size_t shifts = 0;
	while (shifts <= sizeof(ec_z)*8) {
		// 14. Shift the ECC once by setting R71=02h and increment a software counter
		c = crc32_bit(c, (bitswap(0x140A0445)<<1)|1, 0); shifts++;
		// 15. Test to see if software counter > record length. If yes, error is uncorrectable.
//		if (shifts > (sizeof(ec_z)*8)) break;
		// 16. Test to see if R72=0 (ECC bits 0-23). If yes, continue to step 17, else go to step 14
		// 17. Test to see if R73 bits 0,1,2 are 0. If yes, continue, else go to step 14
		if ((c & 0x03FFFFFF) != 0) continue;
		// TA DA!
		printf("error syn %08X\n", c);
		break;
	}

	if (shifts > sizeof(ec_z)*8) {
		printf("Couldn't find a valid syndrome. Error is uncorrectable.\n");
		return -1;
	}

	// compensate for offset
	shifts -= 24;

	// Calculate byte offset. Shift count is from the end of the sector buffer. We want offset from start.
	// Also, C arrays are zero-based, hence the -1.
	size_t byte_ofs = sizeof(ec_z) - (shifts/8) - 1;
	// Calculate bit offset. We need this to realign the error pattern.
	size_t bit_ofs = 8 - (shifts % 8);
	size_t bit_ofs_b = (shifts % 8);
	uint8_t error_pattern_a = bitswap(c) >> (8-(shifts % 8));
	uint8_t error_pattern_b = bitswap(c) << (shifts % 8);

	printf("Shift counter: %d bits (%d bytes, %d remainder)\n", shifts, shifts/8, shifts%8);
	printf("Byte offset: %d\n", byte_ofs);
	printf("Bit offsets: %d %d\n", bit_ofs, bit_ofs_b);

	printf("Original bytes: %02X %02X\n", ec_z[byte_ofs], ec_z[byte_ofs+1]);
	printf("Error patterns: %02X %02X\n", error_pattern_a, error_pattern_b);
	ec_z[byte_ofs] ^= error_pattern_a;
	ec_z[byte_ofs+1] ^= error_pattern_b;
	printf("Repaired bytes: %02X %02X\n", ec_z[byte_ofs], ec_z[byte_ofs+1]);

	// Reset polynomial and recalculate CRC
	c = crc32(0xFFFFFFFF, 0x140A0445, ec_z, sizeof(ec_z));
	printf("New CRC32:      %08X (should be zero)\n", c);

/*
	// Exhaustive search for a polynomial which produces the required output...
	unsigned char z[] = { 0xa1, 0xf8 };

	for (POLY=1; POLY<0xFFFFFFFFul; POLY++) {
		if (crc32(0xffffffff, z, 2) == 0xB517894A) {
			printf("HIT: poly=%08lX\n", (unsigned long)POLY);
		}
	}
*/
	return 0;
}
